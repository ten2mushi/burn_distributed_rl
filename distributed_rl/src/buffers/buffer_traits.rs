//! Buffer trait abstractions for different RL algorithms.

use crate::core::transition::Trajectory;

/// Base trait for experience buffers.
///
/// Provides common interface for buffers that actors push to and learners consume from.
pub trait ExperienceBuffer: Send + Sync {
    /// Transition type stored in this buffer
    type Transition: Clone + Send;
    /// Batch type returned for training
    type Batch;

    /// Push transitions from actor (should be non-blocking or fast).
    fn push(&self, transitions: Vec<Self::Transition>);

    /// Get data for training (semantics depend on algorithm).
    fn get_batch(&self) -> Option<Self::Batch>;

    /// Current number of stored transitions.
    fn len(&self) -> usize;

    /// Check if buffer is empty.
    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Check if ready for training.
    fn is_ready(&self) -> bool;
}

/// On-policy buffer: data consumed once then discarded (PPO, A2C).
///
/// Key characteristics:
/// - Data is generated by current policy
/// - Used once for training, then cleared
/// - No replay (each transition used exactly once)
pub trait OnPolicyBuffer: ExperienceBuffer {
    /// Consume all data (clears buffer after return).
    fn consume(&self) -> Self::Batch;

    /// Signal that a rollout is complete and ready for training.
    fn mark_ready(&self);

    /// Wait for buffer to be ready (blocking).
    fn wait_ready(&self) -> bool;
}

/// Trajectory-based buffer for algorithms needing episode structure (IMPALA).
///
/// Key characteristics:
/// - Stores complete or partial trajectories
/// - Supports multiple actors pushing concurrently
/// - FIFO consumption (oldest trajectories first)
pub trait TrajectoryBuffer: ExperienceBuffer {
    /// Push a complete trajectory.
    fn push_trajectory(&self, trajectory: Trajectory<Self::Transition>);

    /// Get batch of trajectories.
    fn sample_trajectories(&self, n: usize) -> Option<Vec<Trajectory<Self::Transition>>>;
}
